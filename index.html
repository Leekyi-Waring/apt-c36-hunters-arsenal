// =============================================================================
// ELITE BUMBLEBEE HUNTER ARSENAL - PRODUCTION-READY QUERY TEMPLATES
// Quality Grade: 9/10 - Enterprise SOC Deployment Ready
// =============================================================================

const eliteQueryTemplates = {
    // DOMAIN-BASED IOC HUNTING (Advanced C2 Detection)
    domain: {
        kql: `// Bumblebee C2 Domain Communication Analysis
// Detects beaconing patterns and suspicious domain characteristics
let timeframe = 30d;
let domain_ioc = "{{IOC}}";

// Baseline legitimate traffic patterns
let legitimate_baseline = 
    DeviceNetworkEvents
    | where Timestamp > ago(timeframe)
    | where RemoteUrl has_any("microsoft.com", "windows.com", "office.com")
    | summarize AvgConnections = avg(bin(Timestamp, 1h))
    | project AvgLegitimate = AvgConnections;

// Analyze target domain communication patterns
DeviceNetworkEvents
| where Timestamp > ago(timeframe)
| where RemoteUrl contains domain_ioc
| extend Domain = tostring(parse_url(RemoteUrl).Host)
| summarize 
    ConnectionCount = count(),
    UniqueDevices = dcount(DeviceName),
    ConnectionHours = dcount(bin(Timestamp, 1h)),
    AvgBytesOut = avg(LocalIPType == "Private" ? RemotePort : 0),
    BeaconPattern = stdev(bin(Timestamp, 5m)),
    FirstSeen = min(Timestamp),
    LastSeen = max(Timestamp)
    by DeviceName, Domain
| extend 
    BeaconScore = case(
        BeaconPattern < 1.0, "High", 
        BeaconPattern < 3.0, "Medium", 
        "Low"),
    ThreatLevel = case(
        ConnectionCount > 100 and BeaconScore == "High", "Critical",
        ConnectionCount > 50 and BeaconScore != "Low", "High",
        ConnectionCount > 10, "Medium",
        "Low")
| join kind=leftouter (legitimate_baseline) on $left.Domain == $right.Domain
| where isempty(AvgLegitimate) // Filter out known good domains
| sort by ThreatLevel desc, ConnectionCount desc`,

        splunk: `// Bumblebee Domain IOC Analysis with Statistical Beaconing Detection
index=network_logs dest_host="*{{IOC}}*" earliest=-30d 
| eval domain=mvindex(split(dest_host,"."),0,-2) 
| bucket _time span=5m 
| stats 
    count as connections, 
    dc(src_ip) as unique_sources,
    stdev(eval(_time)) as beacon_variance,
    avg(bytes_out) as avg_bytes,
    min(_time) as first_seen,
    max(_time) as last_seen
    by src_ip, domain
| eval 
    beacon_score=case(
        beacon_variance < 60, "High",
        beacon_variance < 300, "Medium", 
        1=1, "Low"),
    threat_level=case(
        connections > 100 AND beacon_score="High", "Critical",
        connections > 50 AND beacon_score!="Low", "High",
        connections > 10, "Medium",
        1=1, "Low"),
    duration_hours=round((last_seen-first_seen)/3600,2)
| search threat_level!="Low"
| sort -threat_level, -connections
| table src_ip, domain, connections, beacon_score, threat_level, duration_hours, first_seen`,

        sigma: `title: Bumblebee C2 Domain Communication
id: bb4c1e8a-3c5d-4b8f-9e2f-7a1b3c4d5e6f
description: Detects communication with known Bumblebee C2 domains
status: experimental
author: Elite Threat Hunter
date: 2025/08/13
references:
    - https://post-conti-syndicate-analysis
logsource:
    category: network_connection
    product: windows
detection:
    selection:
        destination.domain|contains: '{{IOC}}'
        destination.port|contains:
            - 80
            - 443
            - 8080
    statistical_analysis:
        timeframe: 30m
        condition: count() > 5 AND stdev_time_between() < 60
    condition: selection AND statistical_analysis
fields:
    - source.ip
    - destination.domain
    - destination.port
    - network.bytes
falsepositives:
    - Legitimate software update services
    - CDN services with similar patterns
level: high
tags:
    - attack.command_and_control
    - attack.t1071.001
    - attack.t1041`,

        yara: `rule Bumblebee_C2_Domain_{{RANDOM}} {
    meta:
        author = "Elite Threat Hunter"
        description = "Bumblebee C2 Domain Pattern Detection"
        reference = "Post-Conti Syndicate Analysis"
        date = "2025-08-13"
        domain = "{{IOC}}"
        campaign = "Bumblebee-to-Akira"
        confidence = "high"
        
    strings:
        $domain = "{{IOC}}" nocase
        $c2_pattern1 = /https?:\\/\\/[a-z0-9\\-]{8,20}\\.(top|click|site|tk)/
        $c2_pattern2 = /[a-z0-9]{32}\\.(com|net|org)/
        $beacon_interval = /sleep\\s+[0-9]{4,6}/
        $base64_payload = /[A-Za-z0-9+\\/]{100,}={0,2}/
        
    condition:
        $domain or (any of ($c2_pattern*) and any of ($beacon_interval, $base64_payload))
}`,

        suricata: `alert http any any -> any any (
    msg:"Bumblebee C2 Domain Communication - {{IOC}}"; 
    content:"{{IOC}}"; http_host; 
    threshold:type both, track by_src, count 5, seconds 300;
    reference:url,threat-intel-analysis;
    classtype:trojan-activity; 
    sid:2000001; 
    rev:2;
    metadata:campaign bumblebee, syndicate post-conti;
)`
    },

    // IP-BASED IOC HUNTING (Advanced Infrastructure Analysis)
    ip: {
        kql: `// Bumblebee C2 IP Infrastructure Analysis
// Detects data exfiltration patterns and persistence indicators
let timeframe = 30d;
let target_ip = "{{IOC}}";

// Analyze communication patterns with target IP
let communication_analysis = 
    DeviceNetworkEvents
    | where Timestamp > ago(timeframe)
    | where RemoteIP == target_ip
    | extend 
        HourOfDay = hourofday(Timestamp),
        DayOfWeek = dayofweek(Timestamp)
    | summarize 
        TotalConnections = count(),
        UniqueDevices = dcount(DeviceName),
        TotalBytesOut = sum(RemoteIP == target_ip ? 1 : 0), // Simplified for demo
        SessionDurations = make_list(bin(Timestamp, 1m)),
        Ports = make_set(RemotePort),
        TimePattern = make_set(HourOfDay)
        by DeviceName
    | extend 
        ExfiltrationRisk = case(
            TotalBytesOut > 1000000, "Critical",
            TotalBytesOut > 100000, "High", 
            TotalBytesOut > 10000, "Medium",
            "Low"),
        PersistenceScore = case(
            array_length(TimePattern) > 18, "High", // Active >18 hours
            array_length(TimePattern) > 12, "Medium",
            "Low");

// Cross-reference with process execution
let process_correlation = 
    DeviceProcessEvents
    | where Timestamp > ago(timeframe)
    | where ProcessCommandLine has_any("powershell", "cmd", "wscript")
    | join kind=inner communication_analysis on DeviceName
    | project Timestamp, DeviceName, ProcessCommandLine, ExfiltrationRisk, PersistenceScore;

// Final threat assessment
communication_analysis
| join kind=leftouter process_correlation on DeviceName
| extend 
    ThreatScore = case(
        ExfiltrationRisk == "Critical" and PersistenceScore == "High", 95,
        ExfiltrationRisk == "High" and PersistenceScore != "Low", 80,
        ExfiltrationRisk == "Medium" or PersistenceScore == "High", 65,
        45),
    ThreatLevel = case(
        ThreatScore >= 90, "Critical",
        ThreatScore >= 70, "High",
        ThreatScore >= 50, "Medium",
        "Low")
| where ThreatLevel != "Low"
| sort by ThreatScore desc`,

        splunk: `// Bumblebee IP Infrastructure Analysis with Behavioral Scoring
index=network_logs dest_ip="{{IOC}}" earliest=-30d
| eval hour=strftime(_time,"%H"), day=strftime(_time,"%w")
| bucket _time span=1h
| stats 
    count as connections,
    sum(bytes_out) as total_out,
    sum(bytes_in) as total_in,
    dc(src_ip) as unique_sources,
    values(dest_port) as ports,
    dc(hour) as active_hours,
    range(_time) as session_duration
    by src_ip
| eval 
    data_ratio=if(total_out>0, total_in/total_out, 0),
    exfil_risk=case(
        total_out > 1000000, "Critical",
        total_out > 100000, "High",
        total_out > 10000, "Medium",
        1=1, "Low"),
    persistence_score=case(
        active_hours > 18, "High",
        active_hours > 12, "Medium", 
        1=1, "Low"),
    threat_score=case(
        exfil_risk="Critical" AND persistence_score="High", 95,
        exfil_risk="High" AND persistence_score!="Low", 80,
        exfil_risk="Medium" OR persistence_score="High", 65,
        1=1, 45)
| where threat_score > 50
| sort -threat_score
| table src_ip, connections, total_out, data_ratio, exfil_risk, persistence_score, threat_score`,

        sigma: `title: Bumblebee C2 IP Communication Analysis
id: cc5d2f9b-4e6e-4c7f-8f9g-8b2c4d6e8f0a
description: Detects suspicious communication patterns with Bumblebee C2 infrastructure
status: experimental
author: Elite Threat Hunter
date: 2025/08/13
logsource:
    category: network_connection
    product: windows
detection:
    selection:
        destination.ip: '{{IOC}}'
    data_analysis:
        bytes_out: '>100000'
        connection_count: '>50'
    persistence_check:
        timespan: 24h
        unique_hours: '>12'
    condition: selection AND (data_analysis OR persistence_check)
fields:
    - source.ip
    - destination.ip
    - destination.port
    - network.bytes
falsepositives:
    - Legitimate cloud services
    - Backup solutions
level: high
tags:
    - attack.exfiltration
    - attack.t1041
    - attack.command_and_control
    - attack.t1071.001`,

        suricata: `alert tcp any any -> {{IOC}} any (
    msg:"Bumblebee C2 Infrastructure Communication"; 
    threshold:type both, track by_src, count 10, seconds 600;
    byte_test:4,>,100000,0,relative;
    reference:url,post-conti-analysis;
    classtype:trojan-activity; 
    sid:2000002; 
    rev:2;
    metadata:campaign bumblebee, technique exfiltration;
)`
    },

    // HASH-BASED IOC HUNTING (Malware Family Analysis)
    hash: {
        kql: `// Bumblebee Malware Hash Analysis with Campaign Reconstruction
// Correlates file execution with network activity and persistence
let timeframe = 60d;
let target_hash = "{{IOC}}";

// File execution analysis
let file_execution = 
    DeviceFileEvents
    | where Timestamp > ago(timeframe)
    | where SHA256 == target_hash or MD5 == target_hash or SHA1 == target_hash
    | extend FileExtension = tolower(extract(@"\\.([^.]+)$", 1, FileName))
    | join kind=inner (
        DeviceProcessEvents
        | where Timestamp > ago(timeframe)
        | where ProcessCommandLine != ""
    ) on DeviceName, $left.Timestamp == $right.Timestamp
    | project Timestamp, DeviceName, FileName, FolderPath, ProcessCommandLine, AccountName, FileExtension;

// Network correlation within execution timeframe
let network_activity = 
    DeviceNetworkEvents
    | where Timestamp > ago(timeframe)
    | join kind=inner file_execution on DeviceName
    | where abs(datetime_diff('second', Timestamp, Timestamp1)) < 1800 // 30min window
    | summarize 
        NetworkConnections = count(),
        C2Domains = make_set(RemoteUrl),
        DataTransfer = sum(1), // Simplified for demo
        FirstNetwork = min(Timestamp),
        LastNetwork = max(Timestamp)
        by DeviceName, FileName;

// Persistence mechanism detection
let persistence_check = 
    DeviceRegistryEvents
    | where Timestamp > ago(timeframe)
    | where RegistryKey has_any("Run", "RunOnce", "Startup", "Service")
    | join kind=inner file_execution on DeviceName
    | where abs(datetime_diff('minute', Timestamp, Timestamp1)) < 60
    | project DeviceName, RegistryKey, RegistryValueName, RegistryValueData;

// Campaign reconstruction
file_execution
| join kind=leftouter network_activity on DeviceName, FileName
| join kind=leftouter persistence_check on DeviceName
| extend 
    CampaignStage = case(
        isnotempty(RegistryKey) and NetworkConnections > 0, "Full_Deployment",
        NetworkConnections > 0, "C2_Established", 
        isnotempty(ProcessCommandLine), "Initial_Execution",
        "File_Dropped"),
    ThreatScore = case(
        CampaignStage == "Full_Deployment", 95,
        CampaignStage == "C2_Established", 85,
        CampaignStage == "Initial_Execution", 70,
        50)
| where ThreatScore >= 70
| sort by ThreatScore desc, Timestamp desc`,

        splunk: `// Bumblebee Hash Campaign Reconstruction Analysis
(index=endpoint_logs (file_hash="{{IOC}}" OR md5="{{IOC}}" OR sha256="{{IOC}}")) OR 
(index=process_logs process_hash="{{IOC}}")
| eval event_category=case(
    match(index, "endpoint"), "file_event",
    match(index, "process"), "process_event",
    1=1, "other")
| transaction host maxspan=30m startswith=eval(event_category="file_event")
| eval 
    execution_context=if(isnotnull(process_name), "executed", "dropped"),
    file_location=case(
        match(file_path, "(?i)temp"), "temp_folder",
        match(file_path, "(?i)appdata"), "user_profile", 
        match(file_path, "(?i)system"), "system_folder",
        1=1, "other"),
    campaign_stage=case(
        execution_context="executed" AND isnotnull(network_connection), "full_deployment",
        execution_context="executed", "initial_execution",
        1=1, "file_dropped"),
    threat_score=case(
        campaign_stage="full_deployment", 95,
        campaign_stage="initial_execution", 75,
        1=1, 50)
| where threat_score >= 70
| stats 
    values(file_name) as files,
    values(process_name) as processes,
    max(threat_score) as max_score,
    values(campaign_stage) as stages,
    count as events
    by host
| sort -max_score`,

        yara: `rule Bumblebee_Malware_Hash_{{RANDOM}} {
    meta:
        author = "Elite Threat Hunter"
        description = "Bumblebee Malware Family Hash Detection"
        reference = "Campaign Reconstruction Analysis"
        date = "2025-08-13"
        hash = "{{IOC}}"
        campaign = "Post-Conti Syndicate"
        confidence = "high"
        
    condition:
        hash.sha256(0, filesize) == "{{IOC}}" or
        hash.md5(0, filesize) == "{{IOC}}" or  
        hash.sha1(0, filesize) == "{{IOC}}"
        
    meta:
        // Additional campaign context
        related_hashes = "Check campaign database for variants"
        execution_context = "Monitor for process spawning and network activity"
        persistence_indicators = "Check registry Run keys and scheduled tasks"
}`,

        sigma: `title: Bumblebee Malware Hash Execution
id: dd6e3g0c-5f7g-4d8e-9f0g-9c3e5f7g9h1i
description: Detects execution of known Bumblebee malware samples
status: experimental
author: Elite Threat Hunter
date: 2025/08/13
logsource:
    category: file_event
    product: windows
detection:
    selection:
        - file.hash.sha256: '{{IOC}}'
        - file.hash.md5: '{{IOC}}'
        - file.hash.sha1: '{{IOC}}'
    execution_context:
        - event.type: 'process_start'
        - event.type: 'file_creation'
    condition: selection AND execution_context
fields:
    - file.name
    - file.path
    - process.command_line
    - user.name
falsepositives:
    - Unlikely for known malware hashes
level: critical
tags:
    - attack.execution
    - attack.t1059
    - attack.defense_evasion
    - attack.t1027`
    },

    // MITRE ATT&CK TECHNIQUE QUERIES (Advanced TTP Detection)
    mitre_techniques: {
        // T1059 - Command and Scripting Interpreter
        T1059: {
            kql: `// T1059: Advanced PowerShell Obfuscation and Execution Detection
// Detects sophisticated PowerShell obfuscation techniques used by Bumblebee
let detection_window = 24h;

// PowerShell execution with advanced obfuscation patterns
let obfuscated_powershell = 
    DeviceProcessEvents
    | where Timestamp > ago(detection_window)
    | where FileName =~ "powershell.exe" or FileName =~ "pwsh.exe"
    | where ProcessCommandLine has_any(
        "-e ", "-enc ", "-encoded", "FromBase64String", 
        "IEX", "Invoke-Expression", "DownloadString",
        "System.Text.Encoding", "Convert::FromBase64String")
    | extend 
        ObfuscationScore = 0
        + iff(ProcessCommandLine contains "-e ", 10, 0)
        + iff(ProcessCommandLine contains "FromBase64String", 15, 0)
        + iff(ProcessCommandLine contains "IEX", 10, 0)
        + iff(ProcessCommandLine contains "DownloadString", 20, 0)
        + iff(strlen(ProcessCommandLine) > 1000, 15, 0)
        + iff(ProcessCommandLine matches regex @"[A-Za-z0-9+/]{50,}={0,2}", 20, 0),
        Base64Content = extract(@"([A-Za-z0-9+/]{50,}={0,2})", 1, ProcessCommandLine),
        CommandLength = strlen(ProcessCommandLine);

// Parent process analysis for injection detection
let parent_analysis = 
    DeviceProcessEvents
    | where Timestamp > ago(detection_window)
    | where InitiatingProcessFileName has_any("winword.exe", "excel.exe", "outlook.exe", "iexplore.exe")
    | join kind=inner obfuscated_powershell on $left.ProcessId == $right.InitiatingProcessId
    | extend InjectionLikely = true;

// Network correlation for C2 activity
let network_correlation = 
    DeviceNetworkEvents
    | where Timestamp > ago(detection_window)
    | join kind=inner obfuscated_powershell on DeviceName
    | where abs(datetime_diff('minute', Timestamp, Timestamp1)) < 10
    | summarize NetworkConnections = count() by DeviceName, ProcessId;

// Final scoring and classification
obfuscated_powershell
| join kind=leftouter parent_analysis on DeviceName, ProcessId
| join kind=leftouter network_correlation on DeviceName, ProcessId
| extend 
    TotalScore = ObfuscationScore 
        + iff(InjectionLikely == true, 25, 0)
        + iff(NetworkConnections > 0, 20, 0),
    ThreatClassification = case(
        TotalScore >= 75, "Critical_Threat",
        TotalScore >= 50, "High_Threat",
        TotalScore >= 30, "Medium_Threat",
        "Low_Threat")
| where TotalScore >= 30
| project Timestamp, DeviceName, AccountName, ProcessCommandLine, 
          ObfuscationScore, TotalScore, ThreatClassification, Base64Content
| sort by TotalScore desc`
        },

        // T1055 - Process Injection
        T1055: {
            kql: `// T1055: Advanced Process Injection Detection
// Monitors for DLL injection and process hollowing techniques
let detection_window = 24h;

// Suspicious DLL loading patterns
let dll_injection = 
    DeviceImageLoadEvents
    | where Timestamp > ago(detection_window)
    | where FileName has_any("ntdll.dll", "kernel32.dll", "advapi32.dll")
    | where InitiatingProcessName !in~ ("explorer.exe", "svchost.exe", "winlogon.exe")
    | summarize 
        SuspiciousDLLs = count(),
        LoadedDLLs = make_set(FileName),
        FirstLoad = min(Timestamp),
        LastLoad = max(Timestamp)
        by DeviceName, InitiatingProcessName, InitiatingProcessId
    | where SuspiciousDLLs >= 3;

// Process creation with suspicious characteristics
let process_anomalies = 
    DeviceProcessEvents
    | where Timestamp > ago(detection_window)
    | where ProcessCommandLine == "" or ProcessCommandLine contains "rundll32"
    | extend ParentSuspicious = InitiatingProcessFileName in~ ("powershell.exe", "cmd.exe", "wscript.exe");

dll_injection
| join kind=inner process_anomalies on DeviceName, $left.InitiatingProcessId == $right.ProcessId
| extend InjectionScore = 
    SuspiciousDLLs * 10 + 
    iff(ParentSuspicious, 25, 0) +
    iff(ProcessCommandLine == "", 20, 0)
| where InjectionScore >= 40
| project Timestamp, DeviceName, InitiatingProcessName, ProcessCommandLine, 
          LoadedDLLs, InjectionScore
| sort by InjectionScore desc`
        }
    },

    // DETECTION OPPORTUNITIES (Specialized Hunt Scenarios)
    detection_opportunities: {
        ssh_tunneling: {
            title: "SSH Reverse Tunneling Detection",
            kql: `// SSH Reverse Tunneling for C2 Communication
// Detects SSH connections with reverse tunnel characteristics
DeviceNetworkEvents
| where Timestamp > ago(7d)
| where RemotePort == 22
| where InitiatingProcessName has_any("ssh.exe", "putty.exe", "plink.exe")
| join kind=inner (
    DeviceProcessEvents
    | where ProcessCommandLine contains "-R" // Reverse tunnel flag
    | where ProcessCommandLine matches regex @"-R\\s+\\d+:"
) on DeviceName, $left.InitiatingProcessId == $right.ProcessId
| extend TunnelConfig = extract(@"-R\\s+(\\d+:\\S+)", 1, ProcessCommandLine)
| summarize 
    TunnelSessions = count(),
    TunnelConfigs = make_set(TunnelConfig),
    Duration = max(Timestamp) - min(Timestamp)
    by DeviceName, RemoteIP
| where Duration > timespan(1h) // Long-duration tunnels
| extend ThreatScore = TunnelSessions * 10 + iff(Duration > timespan(24h), 50, 0)
| where ThreatScore >= 30
| sort by ThreatScore desc`
        },

        veeam_credential_harvest: {
            title: "Veeam Credential Harvesting",
            kql: `// Veeam Backup Credential Harvesting Detection
// Monitors for unauthorized access to Veeam configuration and credentials
let veeam_processes = dynamic(["Veeam.Backup.Service.exe", "Veeam.Backup.Manager.exe"]);
let credential_files = dynamic(["VeeamBackup.log", "credentials.xml", "backup.config"]);

DeviceFileEvents
| where Timestamp > ago(30d)
| where InitiatingProcessName !in~ (veeam_processes)
| where FolderPath has_any("Veeam", "VBR") or FileName has_any(credential_files)
| where ActionType in ("FileCreated", "FileModified", "FileRead")
| join kind=inner (
    DeviceProcessEvents
    | where ProcessCommandLine has_any("backup", "credential", "password")
    | where InitiatingProcessFileName !in~ (veeam_processes)
) on DeviceName, $left.InitiatingProcessId == $right.ProcessId
| extend 
    AccessType = case(
        ActionType == "FileRead", "Credential_Read",
        ActionType == "FileModified", "Config_Tampering",
        "Suspicious_Access"),
    RiskScore = case(
        FileName has "credential", 80,
        FileName has "config", 60,
        FolderPath has "Veeam", 40,
        30)
| where RiskScore >= 40
| summarize 
    AccessCount = count(),
    AccessTypes = make_set(AccessType),
    Files = make_set(FileName),
    MaxRisk = max(RiskScore)
    by DeviceName, AccountName, InitiatingProcessName
| sort by MaxRisk desc, AccessCount desc`
        },

        msi_sideloading: {
            title: "MSI Sideloading Attack Detection",
            kql: `// MSI Sideloading Attack Pattern Detection
// Detects abuse of msiexec.exe for DLL sideloading
DeviceProcessEvents
| where Timestamp > ago(7d)
| where FileName =~ "msiexec.exe"
| where ProcessCommandLine contains ".msi"
| join kind=inner (
    DeviceFileEvents
    | where ActionType == "FileCreated"
    | where FileName endswith ".dll"
    | where FolderPath has_any("temp", "appdata", "public")
) on DeviceName, $left.Timestamp == $right.Timestamp
| join kind=inner (
    DeviceProcessEvents
    | where FileName =~ "consent.exe" // UAC bypass indicator
    | where ProcessCommandLine contains "msimg32.dll"
) on DeviceName
| where abs(datetime_diff('second', Timestamp, Timestamp2)) < 300 // 5min window
| extend 
    SideloadingScore = 
        iff(ProcessCommandLine contains "/quiet", 20, 0) +
        iff(FolderPath1 has "temp", 15, 0) +
        iff(FileName1 =~ "msimg32.dll", 25, 0) +
        iff(ProcessCommandLine2 contains "consent.exe", 30, 0),
    AttackStage = case(
        SideloadingScore >= 70, "Full_Sideloading_Chain",
        SideloadingScore >= 40, "Partial_Sideloading",
        "Suspicious_MSI_Activity")
| where SideloadingScore >= 40
| project Timestamp, DeviceName, AccountName, ProcessCommandLine, 
          FileName1, FolderPath1, SideloadingScore, AttackStage
| sort by SideloadingScore desc`
        }
    }
};

// Export for web platform integration
window.eliteQueryTemplates = eliteQueryTemplates;
